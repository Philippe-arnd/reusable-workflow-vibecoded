name: Reusable Docker Validation

on:
  workflow_call:
    inputs:
      use-compose:
        description: 'Use docker compose instead of single Dockerfile + docker run'
        type: boolean
        default: false

      # Single Dockerfile mode
      dockerfile-path:
        description: 'Path to Dockerfile (single mode only)'
        type: string
        default: 'Dockerfile'
      image-tag:
        description: 'Tag for the built image (single mode only)'
        type: string
        default: 'app:ci-test'
      build-args:
        description: 'Docker build args, one --build-arg KEY=VALUE per line (single mode only)'
        type: string
        default: ''
      app-port:
        description: 'Container port to map and health-check (single mode only)'
        type: number
        default: 3000
      health-endpoint:
        description: 'HTTP path to poll for health check'
        type: string
        default: '/api/health'
      health-retries:
        description: 'Number of health check attempts before failing'
        type: number
        default: 30
      health-interval-seconds:
        description: 'Seconds between health check attempts'
        type: number
        default: 3

      # postgres (single mode only â€” compose mode manages its own services via compose file)
      postgres-image:
        description: 'Postgres Docker image (single mode only)'
        type: string
        default: 'postgres:18-alpine'
      postgres-db:
        description: 'Test database name (single mode only)'
        type: string
        default: 'test_db'
      postgres-admin-password:
        description: 'Postgres superuser password (single mode only)'
        type: string
        default: 'postgres'
      app-user:
        description: 'Non-superuser to create for RLS (single mode only)'
        type: string
        default: 'app_user'
      app-password:
        description: 'Password for app_user (single mode only)'
        type: string
        default: 'app_password'

      # App env vars (single mode only â€” compose mode uses its own .env / compose file)
      app-env:
        description: 'Env vars for the app container, one KEY=VALUE per line (single mode only)'
        type: string
        default: ''

      # Docker Compose mode
      compose-services-to-build:
        description: 'Space-separated list of services to build (compose mode only, empty = all)'
        type: string
        default: ''
      compose-health-service:
        description: 'Service name whose health to check (compose mode only)'
        type: string
        default: 'server'
      compose-health-port:
        description: 'Port inside the health service container to check (compose mode only)'
        type: number
        default: 3000

jobs:
  docker-build-validate:
    name: ğŸ³ Build & Validate Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v6

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # â”€â”€ Single Dockerfile mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ—ï¸ Build Docker image (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          BUILD_ARGS=""
          if [ -n "${{ inputs.build-args }}" ]; then
            while IFS= read -r line; do
              [ -n "$line" ] && BUILD_ARGS="$BUILD_ARGS $line"
            done <<< "${{ inputs.build-args }}"
          fi
          docker build $BUILD_ARGS \
            --tag ${{ inputs.image-tag }} \
            --file ${{ inputs.dockerfile-path }} \
            .

      - name: ğŸŒ Create Docker network (single mode)
        if: ${{ !inputs.use-compose }}
        run: docker network create ci-test-net

      - name: ğŸ›¢ï¸ Start PostgreSQL (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          docker run -d \
            --name ci-postgres \
            --network ci-test-net \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=${{ inputs.postgres-admin-password }} \
            -e POSTGRES_DB=${{ inputs.postgres-db }} \
            ${{ inputs.postgres-image }}

      - name: â³ Wait for PostgreSQL (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          until docker exec ci-postgres pg_isready -U postgres; do
            echo "Waiting for postgres..."
            sleep 2
          done

      - name: ğŸ‘¤ Create app_user (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          docker exec ci-postgres psql -U postgres -d ${{ inputs.postgres-db }} -c \
            "CREATE USER ${{ inputs.app-user }} WITH PASSWORD '${{ inputs.app-password }}';
             GRANT CONNECT ON DATABASE ${{ inputs.postgres-db }} TO ${{ inputs.app-user }};"

      - name: ğŸš€ Start application container (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          APP_ENV_ARGS=""
          if [ -n "${{ inputs.app-env }}" ]; then
            while IFS= read -r line; do
              [ -n "$line" ] && APP_ENV_ARGS="$APP_ENV_ARGS -e $line"
            done <<< "${{ inputs.app-env }}"
          fi
          docker run -d \
            --name ci-app \
            --network ci-test-net \
            -p ${{ inputs.app-port }} \
            -e DATABASE_URL=postgresql://${{ inputs.app-user }}:${{ inputs.app-password }}@ci-postgres:5432/${{ inputs.postgres-db }} \
            -e ADMIN_DATABASE_URL=postgresql://postgres:${{ inputs.postgres-admin-password }}@ci-postgres:5432/${{ inputs.postgres-db }} \
            $APP_ENV_ARGS \
            ${{ inputs.image-tag }}

      - name: ğŸ”Œ Get dynamic app port (single mode)
        if: ${{ !inputs.use-compose }}
        id: get-port
        run: |
          APP_PORT=$(docker port ci-app ${{ inputs.app-port }} | cut -d: -f2)
          echo "app_port=$APP_PORT" >> $GITHUB_OUTPUT

      - name: ğŸ¥ Health check (single mode)
        if: ${{ !inputs.use-compose }}
        run: |
          PORT="${{ steps.get-port.outputs.app_port }}"
          for i in $(seq 1 ${{ inputs.health-retries }}); do
            if curl -sf "http://localhost:${PORT}${{ inputs.health-endpoint }}"; then
              echo "Application is healthy"
              exit 0
            fi
            echo "Attempt $i/${{ inputs.health-retries }}: waiting..."
            sleep ${{ inputs.health-interval-seconds }}
          done
          echo "Application failed to become healthy"
          docker logs ci-app
          exit 1

      - name: ğŸ§¹ Cleanup (single mode)
        if: ${{ !inputs.use-compose && always() }}
        run: |
          docker stop ci-app ci-postgres 2>/dev/null || true
          docker rm ci-app ci-postgres 2>/dev/null || true
          docker network rm ci-test-net 2>/dev/null || true

      # â”€â”€ Docker Compose mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ—ï¸ Build images (compose mode)
        if: ${{ inputs.use-compose }}
        run: |
          if [ -n "${{ inputs.compose-services-to-build }}" ]; then
            docker compose build ${{ inputs.compose-services-to-build }}
          else
            docker compose build
          fi

      - name: ğŸš€ Start services (compose mode)
        if: ${{ inputs.use-compose }}
        run: docker compose up -d

      - name: ğŸ¥ Health check (compose mode)
        if: ${{ inputs.use-compose }}
        run: |
          SERVICE="${{ inputs.compose-health-service }}"
          PORT="${{ inputs.compose-health-port }}"
          for i in $(seq 1 ${{ inputs.health-retries }}); do
            if docker compose exec -T "$SERVICE" \
                wget -q -O- "http://localhost:${PORT}${{ inputs.health-endpoint }}" 2>/dev/null; then
              echo "Service $SERVICE is healthy"
              exit 0
            fi
            echo "Attempt $i/${{ inputs.health-retries }}: waiting..."
            sleep ${{ inputs.health-interval-seconds }}
          done
          echo "Service $SERVICE failed to become healthy"
          docker compose logs
          exit 1

      - name: ğŸ§¹ Cleanup (compose mode)
        if: ${{ inputs.use-compose && always() }}
        run: docker compose down -v --remove-orphans
